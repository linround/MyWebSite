{"version":3,"file":"static/js/936.7093ac3a.chunk.js","mappings":"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","sources":["pages/window/WebglImageProcessing/triangles.js","pages/window/WebglImageProcessing/index.js","pages/window/webglCommon/index.js","webpack://my-app-react/./src/pages/window/webglCommon/style.less?3477"],"sourcesContent":["import { createProgramFromStrings } from '../webglCommon'\r\n\r\nexport function triangles(canvas, image) {\r\n  // Get A WebGL context\r\n  const gl = canvas.getContext('webgl')\r\n  if (!gl) {\r\n    return\r\n  }\r\n  const vertexShaderSource = `\r\n        attribute vec2 a_position;\r\n        attribute vec2 a_texCoord;\r\n        \r\n        uniform vec2 u_resolution;\r\n        \r\n        varying vec2 v_texCoord;\r\n        \r\n        void main() {\r\n           // 像素空间转换到裁剪空间（-1，1）\r\n           vec2 zeroToOne = a_position / u_resolution;\r\n        \r\n           // 转换 0->1 to 0->2\r\n           vec2 zeroToTwo = zeroToOne * 2.0;\r\n        \r\n           // 转换 0->2 to -1->+1 (裁剪空间坐标)\r\n           vec2 clipSpace = zeroToTwo - 1.0;\r\n           // 将y轴反转\r\n           gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\r\n        \r\n           // 传入纹理坐标\r\n           v_texCoord = a_texCoord;\r\n        }\r\n  `\r\n  /**\r\n   * todo\r\n   * sampler2D和vec2、float表示一种数据类型，\r\n   * 只不过sampler2D关键字声明的变量表示一种取样器类型变量，\r\n   * 简单点说就是该变量对应纹理图片的像素数据\r\n   * @type {string}\r\n   */\r\n  const fragmentShaderSource = `\r\n      precision mediump float;\r\n      \r\n      // 纹理信息\r\n      // 2d像素信息\r\n      uniform sampler2D u_image;\r\n      // 纹理大小\r\n      uniform vec2 u_textureSize;\r\n      // 卷积核\r\n      uniform float u_kernel[9];\r\n      // 核权重\r\n      uniform float u_kernelWeight;\r\n      \r\n      // 顶点着色器传入的纹理坐标.\r\n      varying vec2 v_texCoord;\r\n      \r\n      void main() {\r\n         // 1px 像素\r\n         // 图像处理需要其他像素的颜色值怎么办？\r\n         // 由于WebGL的纹理坐标范围是 0.0 到 1.0 ， 那我们可以简单计算出移动一个像素对应的距离\r\n         \r\n         vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;\r\n         \r\n         \r\n         // 以下\r\n         // 第一个参数代表图片纹理，第二个参数代表纹理坐标点，通过GLSL的内建函数texture2D来获取对应位置纹理的颜色RGBA值\r\n         // texture2D函数创建texture2D贴图，并对像素进行操作\r\n         // 取得当前纹理坐标周围坐标的像素值，然后做卷积运算\r\n         // 最终得到一个像素值，这个像素值就是当前片段着色器器的颜色值\r\n         vec4 colorSum =\r\n             texture2D(u_image, v_texCoord + onePixel * vec2(-1, -1)) * u_kernel[0] +\r\n             texture2D(u_image, v_texCoord + onePixel * vec2( 0, -1)) * u_kernel[1] +\r\n             texture2D(u_image, v_texCoord + onePixel * vec2( 1, -1)) * u_kernel[2] +\r\n             texture2D(u_image, v_texCoord + onePixel * vec2(-1,  0)) * u_kernel[3] +\r\n             texture2D(u_image, v_texCoord + onePixel * vec2( 0,  0)) * u_kernel[4] +\r\n             texture2D(u_image, v_texCoord + onePixel * vec2( 1,  0)) * u_kernel[5] +\r\n             texture2D(u_image, v_texCoord + onePixel * vec2(-1,  1)) * u_kernel[6] +\r\n             texture2D(u_image, v_texCoord + onePixel * vec2( 0,  1)) * u_kernel[7] +\r\n             texture2D(u_image, v_texCoord + onePixel * vec2( 1,  1)) * u_kernel[8] ;\r\n      \r\n         gl_FragColor = vec4((colorSum / u_kernelWeight).rgb, 1);\r\n      }\r\n  `\r\n  // 启动一个程序\r\n  const program = createProgramFromStrings(\r\n    gl, vertexShaderSource, fragmentShaderSource\r\n  )\r\n\r\n  // 找到顶点数据的位置\r\n  const positionLocation = gl.getAttribLocation(program, 'a_position')\r\n  const texcoordLocation = gl.getAttribLocation(program, 'a_texCoord')\r\n\r\n  // 创建一个缓冲区，防止裁剪空间中的点\r\n  const positionBuffer = gl.createBuffer()\r\n  // 当当缓冲区指向 positionBuffer\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)\r\n  // 建立一个和图片一样大的矩形（给positionBuffer中注入数据）\r\n  setRectangle(\r\n    gl, 0, 0, image.width, image.height\r\n  )\r\n\r\n  // 为提供一个纹理坐标缓存区\r\n  const texcoordBuffer = gl.createBuffer()\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer)\r\n  gl.bufferData(\r\n    gl.ARRAY_BUFFER, new Float32Array([\r\n      0.0,  0.0,\r\n      1.0,  0.0,\r\n      0.0,  1.0,\r\n      0.0,  1.0,\r\n      1.0,  0.0,\r\n      1.0,  1.0\r\n    ]), gl.STATIC_DRAW\r\n  )\r\n\r\n  // =========================================创建图像纹理=============START========================================\r\n  const texture = gl.createTexture()\r\n  gl.bindTexture(gl.TEXTURE_2D, texture)\r\n\r\n  // 设置纹理参数\r\n  // target: gl.TEXTURE_2D\r\n  // TEXTURE_WRAP_S 纹理坐标水平填充       默认值 gl.CLAMP_TO_EDGE\r\n  gl.texParameteri(\r\n    gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE\r\n  )\r\n\r\n  // TEXTURE_WRAP_T纹理坐标垂直填充        默认值 gl.CLAMP_TO_EDGE\r\n  gl.texParameteri(\r\n    gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE\r\n  )\r\n\r\n  // TEXTURE_MIN_FILTER     纹理缩小滤波器     默认值 gl.CLAMP_TO_EDGE\r\n  gl.texParameteri(\r\n    gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST\r\n  )\r\n\r\n  // TEXTURE_MAG_FILTER  纹理放大滤波器       默认值 gl.NEAREST\r\n  gl.texParameteri(\r\n    gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST\r\n  )\r\n  // 指定根据图像二维纹理图像\r\n  // 参数 ：target, level, internalformat, format, type, ImageData? pixels\r\n  gl.texImage2D(\r\n    gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image\r\n  )\r\n  // =========================================创建图像纹理=============END========================================\r\n\r\n\r\n  // 找到全局变量的位置\r\n  const resolutionLocation = gl.getUniformLocation(program, 'u_resolution')\r\n  const textureSizeLocation = gl.getUniformLocation(program, 'u_textureSize')\r\n  const kernelLocation = gl.getUniformLocation(program, 'u_kernel[0]')\r\n  const kernelWeightLocation = gl.getUniformLocation(program, 'u_kernelWeight')\r\n\r\n  // 定义卷积核\r\n  const kernels = {\r\n    normal: [\r\n      0, 0, 0,\r\n      0, 1, 0,\r\n      0, 0, 0\r\n    ],\r\n    gaussianBlur: [\r\n      0.045, 0.122, 0.045,\r\n      0.122, 0.332, 0.122,\r\n      0.045, 0.122, 0.045\r\n    ],\r\n    gaussianBlur2: [\r\n      1, 2, 1,\r\n      2, 4, 2,\r\n      1, 2, 1\r\n    ],\r\n    gaussianBlur3: [\r\n      0, 1, 0,\r\n      1, 1, 1,\r\n      0, 1, 0\r\n    ],\r\n    unsharpen: [\r\n      -1, -1, -1,\r\n      -1,  9, -1,\r\n      -1, -1, -1\r\n    ],\r\n    sharpness: [\r\n      0, -1, 0,\r\n      -1, 5, -1,\r\n      0, -1, 0\r\n    ],\r\n    sharpen: [\r\n      -1, -1, -1,\r\n      -1, 16, -1,\r\n      -1, -1, -1\r\n    ],\r\n    edgeDetect: [\r\n      -0.125, -0.125, -0.125,\r\n      -0.125,  1,     -0.125,\r\n      -0.125, -0.125, -0.125\r\n    ],\r\n    edgeDetect2: [\r\n      -1, -1, -1,\r\n      -1,  8, -1,\r\n      -1, -1, -1\r\n    ],\r\n    edgeDetect3: [\r\n      -5, 0, 0,\r\n      0, 0, 0,\r\n      0, 0, 5\r\n    ],\r\n    edgeDetect4: [\r\n      -1, -1, -1,\r\n      0,  0,  0,\r\n      1,  1,  1\r\n    ],\r\n    edgeDetect5: [\r\n      -1, -1, -1,\r\n      2,  2,  2,\r\n      -1, -1, -1\r\n    ],\r\n    edgeDetect6: [\r\n      -5, -5, -5,\r\n      -5, 39, -5,\r\n      -5, -5, -5\r\n    ],\r\n    sobelHorizontal: [\r\n      1,  2,  1,\r\n      0,  0,  0,\r\n      -1, -2, -1\r\n    ],\r\n    sobelVertical: [\r\n      1,  0, -1,\r\n      2,  0, -2,\r\n      1,  0, -1\r\n    ],\r\n    previtHorizontal: [\r\n      1,  1,  1,\r\n      0,  0,  0,\r\n      -1, -1, -1\r\n    ],\r\n    previtVertical: [\r\n      1,  0, -1,\r\n      1,  0, -1,\r\n      1,  0, -1\r\n    ],\r\n    boxBlur: [\r\n      0.111, 0.111, 0.111,\r\n      0.111, 0.111, 0.111,\r\n      0.111, 0.111, 0.111\r\n    ],\r\n    triangleBlur: [\r\n      0.0625, 0.125, 0.0625,\r\n      0.125,  0.25,  0.125,\r\n      0.0625, 0.125, 0.0625\r\n    ],\r\n    emboss: [\r\n      -2, -1,  0,\r\n      -1,  1,  1,\r\n      0,  1,  2\r\n    ],\r\n  }\r\n  const initialSelection = 'edgeDetect2'\r\n\r\n  // ===============定义一套UI交互=====================================================START===============\r\n  const ui = document.querySelector('#ui')\r\n  const select = document.createElement('select')\r\n  for (const name in kernels) {\r\n    const option = document.createElement('option')\r\n    option.value = name\r\n    if (name === initialSelection) {\r\n      option.selected = true\r\n    }\r\n    option.appendChild(document.createTextNode(name))\r\n    select.appendChild(option)\r\n  }\r\n  select.onchange = function() {\r\n    drawWithKernel(this.options[this.selectedIndex].value)\r\n  }\r\n  ui.appendChild(select)\r\n  drawWithKernel(initialSelection)\r\n\r\n  function computeKernelWeight(kernel) {\r\n    const weight = kernel.reduce(function(prev, curr) {\r\n      return prev + curr\r\n    })\r\n    return weight <= 0 ? 1 : weight\r\n  }\r\n\r\n  // ===============定义一套UI交互=====================================================END===================\r\n\r\n  function drawWithKernel(name) {\r\n\r\n    // Tell WebGL how to convert from clip space to pixels\r\n    gl.viewport(\r\n      100, -100, gl.canvas.width, gl.canvas.height\r\n    )\r\n\r\n    // Clear the canvas\r\n    gl.clearColor(\r\n      0, 0, 0, 0\r\n    )\r\n    gl.clear(gl.COLOR_BUFFER_BIT)\r\n\r\n    // Tell it to use our program (pair of shaders)\r\n    gl.useProgram(program)\r\n\r\n    // Turn on the position attribute\r\n    gl.enableVertexAttribArray(positionLocation)\r\n\r\n    // Bind the position buffer.\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)\r\n\r\n    // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)\r\n    let size = 2          // 2 components per iteration\r\n    let type = gl.FLOAT   // the data is 32bit floats\r\n    let normalize = false // don't normalize the data\r\n    let stride = 0        // 0 = move forward size * sizeof(type) each iteration to get the next position\r\n    let offset = 0        // start at the beginning of the buffer\r\n    gl.vertexAttribPointer(\r\n      positionLocation, size, type, normalize, stride, offset\r\n    )\r\n\r\n    // Turn on the texcoord attribute\r\n    gl.enableVertexAttribArray(texcoordLocation)\r\n\r\n    // bind the texcoord buffer.\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer)\r\n\r\n    // Tell the texcoord attribute how to get data out of texcoordBuffer (ARRAY_BUFFER)\r\n    size = 2          // 2 components per iteration\r\n    type = gl.FLOAT   // the data is 32bit floats\r\n    normalize = false // don't normalize the data\r\n    stride = 0       // 0 = move forward size * sizeof(type) each iteration to get the next position\r\n    offset = 0        // start at the beginning of the buffer\r\n    gl.vertexAttribPointer(\r\n      texcoordLocation, size, type, normalize, stride, offset\r\n    )\r\n\r\n    // set the resolution\r\n    gl.uniform2f(\r\n      resolutionLocation, gl.canvas.width, gl.canvas.height\r\n    )\r\n\r\n    // set the size of the image\r\n    gl.uniform2f(\r\n      textureSizeLocation, image.width, image.height\r\n    )\r\n\r\n    // set the kernel and it's weight\r\n    gl.uniform1fv(kernelLocation, kernels[name])\r\n    gl.uniform1f(kernelWeightLocation, computeKernelWeight(kernels[name]))\r\n\r\n    // Draw the rectangle.\r\n    const primitiveType = gl.TRIANGLES\r\n    offset = 0\r\n    const  count = 6\r\n    gl.drawArrays(\r\n      primitiveType, offset, count\r\n    )\r\n  }\r\n}\r\n\r\nfunction setRectangle(\r\n  gl, x, y, width, height\r\n) {\r\n  const x1 = x\r\n  const x2 = x + width\r\n  const y1 = y\r\n  const y2 = y + height\r\n  gl.bufferData(\r\n    gl.ARRAY_BUFFER, new Float32Array([\r\n      x1, y1,\r\n      x2, y1,\r\n      x1, y2,\r\n      x1, y2,\r\n      x2, y1,\r\n      x2, y2\r\n    ]), gl.STATIC_DRAW\r\n  )\r\n}\r\n\r\n\r\n\r\n","\r\nimport React, { useRef } from 'react'\r\nimport styles from '../webglCommon/style.less'\r\nimport { triangles } from './triangles'\r\nimport img from './leaves.jpg'\r\n\r\nexport default function WebglImageProcessing() {\r\n  const canvasRef = useRef(null)\r\n  const imgRef = useRef(null)\r\n  const drawTriangles = () => {\r\n    triangles(canvasRef.current, imgRef.current)\r\n  }\r\n  return (\r\n    <div>\r\n      <canvas className={ styles.canvasContainer} ref={canvasRef} width={400} height={300} ></canvas>\r\n      <div>\r\n\r\n        <div id='ui'></div>\r\n        <div className={styles.canvasButton} onClick={drawTriangles}>绘制图形</div>\r\n        <img src={ img } ref={imgRef}/>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","\r\n\r\n// 创建着色器方法，输入参数：渲染上下文，着色器类型，数据源\r\nexport function createShader(\r\n  gl, type, source\r\n) {\r\n  const shader = gl.createShader(type) // 创建着色器对象\r\n  gl.shaderSource(shader, source) // 提供数据源\r\n  gl.compileShader(shader) // 编译 -> 生成着色器\r\n  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS)\r\n  if (success) {\r\n    return shader\r\n  }\r\n\r\n  console.log('getShaderInfoLog', gl.getShaderInfoLog(shader))\r\n  gl.deleteShader(shader)\r\n}\r\n\r\n\r\n// 然后我们将这两个着色器 link（链接）到一个 program（着色程序）\r\nexport function createProgram(\r\n  gl, vertexShader, fragmentShader\r\n) {\r\n  const program = gl.createProgram()\r\n  gl.attachShader(program, vertexShader)\r\n  gl.attachShader(program, fragmentShader)\r\n  gl.linkProgram(program)\r\n\r\n  const success = gl.getProgramParameter(program, gl.LINK_STATUS)\r\n  if (success) {\r\n    return program\r\n  }\r\n\r\n  console.log(gl.getProgramInfoLog(program))\r\n  gl.deleteProgram(program)\r\n}\r\n\r\nexport function createProgramFromStrings(\r\n  gl, vertexShaderSource, fragmentShaderSource\r\n) {\r\n// 创建顶点着色器\r\n  const vertexShader = createShader(\r\n    gl, gl.VERTEX_SHADER, vertexShaderSource\r\n  )\r\n  // 创建片段着色器\r\n  const fragmentShader = createShader(\r\n    gl, gl.FRAGMENT_SHADER, fragmentShaderSource\r\n  )\r\n  // 将两个着色器链接在一起\r\n  return createProgram(\r\n    gl, vertexShader, fragmentShader\r\n  )\r\n}\r\n","// extracted by mini-css-extract-plugin\nexport default {\"canvasContainer\":\"canvasContainer_AroEJ\",\"canvasButton\":\"canvasButton_l2P0H\"};"],"names":["triangles","canvas","image","gl","getContext","program","createProgramFromStrings","positionLocation","getAttribLocation","texcoordLocation","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","x","y","width","height","x1","x2","y1","y2","bufferData","Float32Array","STATIC_DRAW","setRectangle","texcoordBuffer","texture","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","texImage2D","RGBA","UNSIGNED_BYTE","resolutionLocation","getUniformLocation","textureSizeLocation","kernelLocation","kernelWeightLocation","kernels","normal","gaussianBlur","gaussianBlur2","gaussianBlur3","unsharpen","sharpness","sharpen","edgeDetect","edgeDetect2","edgeDetect3","edgeDetect4","edgeDetect5","edgeDetect6","sobelHorizontal","sobelVertical","previtHorizontal","previtVertical","boxBlur","triangleBlur","emboss","initialSelection","ui","document","querySelector","select","createElement","name","option","value","selected","appendChild","createTextNode","onchange","drawWithKernel","this","options","selectedIndex","viewport","clearColor","clear","COLOR_BUFFER_BIT","useProgram","enableVertexAttribArray","size","type","FLOAT","normalize","stride","offset","vertexAttribPointer","uniform2f","uniform1fv","uniform1f","kernel","weight","reduce","prev","curr","computeKernelWeight","primitiveType","TRIANGLES","drawArrays","WebglImageProcessing","canvasRef","useRef","imgRef","className","styles","ref","id","onClick","current","src","img","createShader","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","log","getShaderInfoLog","deleteShader","createProgram","vertexShader","fragmentShader","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","vertexShaderSource","fragmentShaderSource","VERTEX_SHADER","FRAGMENT_SHADER"],"sourceRoot":""}