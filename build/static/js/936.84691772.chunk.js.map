{"version":3,"file":"static/js/936.84691772.chunk.js","mappings":"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","sources":["pages/window/WebglImageProcessing/triangles.js","pages/window/WebglImageProcessing/index.js","pages/window/webglCommon/index.js","webpack://my-app-react/./src/pages/window/webglCommon/style.less?3477"],"sourcesContent":["import { createProgramFromStrings } from '../webglCommon'\r\n// eslint-disable-next-line no-duplicate-imports\r\nimport { kernels } from '../webglCommon'\r\n\r\nexport function triangles(canvas, image) {\r\n  const gl = canvas.getContext('webgl')\r\n  if (!gl) {\r\n    return\r\n  }\r\n  const vertexShaderSource = `\r\n        attribute vec2 a_position;\r\n        attribute vec2 a_texCoord;\r\n        \r\n        uniform vec2 u_resolution;\r\n        \r\n        varying vec2 v_texCoord;\r\n        \r\n        void main() {\r\n           // 像素空间转换到裁剪空间（-1，1）\r\n           vec2 zeroToOne = a_position / u_resolution;\r\n        \r\n           // 转换 0->1 to 0->2\r\n           vec2 zeroToTwo = zeroToOne * 2.0;\r\n        \r\n           // 转换 0->2 to -1->+1 (裁剪空间坐标)\r\n           vec2 clipSpace = zeroToTwo - 1.0;\r\n           // 将y轴反转\r\n           gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\r\n        \r\n           // 传入纹理坐标\r\n           v_texCoord = a_texCoord;\r\n        }\r\n  `\r\n  /**\r\n   * todo\r\n   * sampler2D和vec2、float表示一种数据类型，\r\n   * 只不过sampler2D关键字声明的变量表示一种取样器类型变量，\r\n   * 简单点说就是该变量对应纹理图片的像素数据\r\n   * @type {string}\r\n   */\r\n  const fragmentShaderSource = `\r\n      precision mediump float;\r\n      \r\n      // 纹理信息\r\n      // 2d采样器\r\n      // 使用这个采样器对纹理坐标点进行采样\r\n      uniform sampler2D u_image;\r\n      // 纹理大小\r\n      uniform vec2 u_textureSize;\r\n      // 卷积核\r\n      uniform float u_kernel[9];\r\n      // 核权重\r\n      uniform float u_kernelWeight;\r\n      \r\n      // 顶点着色器传入的纹理坐标.\r\n      varying vec2 v_texCoord;\r\n      \r\n      void main() {\r\n         // 1px 像素\r\n         // 图像处理需要其他像素的颜色值怎么办？\r\n         // 由于WebGL的纹理坐标范围是 0.0 到 1.0 ， 那我们可以简单计算出移动一个像素对应的距离\r\n         \r\n         vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;\r\n         \r\n         \r\n         // 以下\r\n         // 第一个参数代表图片纹理，第二个参数代表纹理坐标点，通过GLSL的内建函数texture2D来获取对应位置纹理的颜色RGBA值\r\n         // texture2D函数创建texture2D贴图，并对像素进行操作\r\n         // 取得当前纹理坐标周围坐标的像素值，然后做卷积运算\r\n         // 最终得到一个像素值，这个像素值就是当前片段着色器器的颜色值\r\n         \r\n         \r\n         \r\n         // vec4 texture2D(sampler2D sampler, vec2 coord)\r\n         // vec4 texture2D(sampler2D sampler, vec2 coord, float bias)\r\n         // 因为texImage2D指定了被绑定的纹理图像\r\n         // 参数1是一个采样器，这个采样器（u_image）会被绑定到当前的纹理图像\r\n         // 参数1： sampler指定将从中检索纹素的纹理绑定到的采样器 。\r\n         // 参数2： coord指定纹理将被采样的纹理坐标。\r\n         // 参数3： bias指定在详细级别计算期间要应用的可选偏差\r\n         // texture2D 函数返回一个纹素，即给定坐标的纹理（颜色）值\r\n         vec4 colorSum =\r\n             texture2D(u_image, v_texCoord + onePixel * vec2(-1, -1)) * u_kernel[0] +\r\n             texture2D(u_image, v_texCoord + onePixel * vec2( 0, -1)) * u_kernel[1] +\r\n             texture2D(u_image, v_texCoord + onePixel * vec2( 1, -1)) * u_kernel[2] +\r\n             texture2D(u_image, v_texCoord + onePixel * vec2(-1,  0)) * u_kernel[3] +\r\n             texture2D(u_image, v_texCoord + onePixel * vec2( 0,  0)) * u_kernel[4] +\r\n             texture2D(u_image, v_texCoord + onePixel * vec2( 1,  0)) * u_kernel[5] +\r\n             texture2D(u_image, v_texCoord + onePixel * vec2(-1,  1)) * u_kernel[6] +\r\n             texture2D(u_image, v_texCoord + onePixel * vec2( 0,  1)) * u_kernel[7] +\r\n             texture2D(u_image, v_texCoord + onePixel * vec2( 1,  1)) * u_kernel[8] ;\r\n      \r\n         gl_FragColor = vec4((colorSum / u_kernelWeight).rgb, 1);\r\n      }\r\n  `\r\n  // 启动一个程序\r\n  const program = createProgramFromStrings(\r\n    gl, vertexShaderSource, fragmentShaderSource\r\n  )\r\n\r\n  // 找到顶点数据的位置\r\n  const positionLocation = gl.getAttribLocation(program, 'a_position')\r\n  const texcoordLocation = gl.getAttribLocation(program, 'a_texCoord')\r\n\r\n  // 创建一个缓冲区，防止裁剪空间中的点\r\n  const positionBuffer = gl.createBuffer()\r\n  // 当当缓冲区指向 positionBuffer\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)\r\n  // 建立一个和图片一样大的矩形（给positionBuffer中注入数据）\r\n  setRectangle(\r\n    gl, 0, 0, image.width, image.height\r\n  )\r\n\r\n  /**\r\n   * todo\r\n   * 为提供一个纹理坐标缓存区\r\n   * 纹理坐标就是纹理与图形的映射关系（顶点和纹理坐标必须按照一致的顺序进行映射）\r\n   * 图形中每个顶点都会关联一个纹理坐标，表示顶点需要从该位置读取纹理图像的数据。\r\n   *\r\n   * 纹理坐标的范围是 0 到 1 之间，\r\n   * 顶点坐标一般是用（ x，y，z）描述，而纹理坐标是用（ s，t，r）描述\r\n   * 常规情况下，纹理坐标默认左下角为（0，0），右上角为（1，1）\r\n   * 纹理坐标的映射关系并不是固定的，可以根据图片的翻转，进行不同的映射，但是不能让图片交叉\r\n   * @type {WebGLBuffer | AudioBuffer}\r\n   */\r\n  const texcoordBuffer = gl.createBuffer()\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer)\r\n  gl.bufferData(\r\n    gl.ARRAY_BUFFER, new Float32Array([\r\n      0.0,  0.0,\r\n      1.0,  0.0,\r\n      0.0,  1.0,\r\n      0.0,  1.0,\r\n      1.0,  0.0,\r\n      1.0,  1.0\r\n    ]), gl.STATIC_DRAW\r\n  )\r\n\r\n  // =========================================创建图像纹理=============START========================================\r\n  const texture = gl.createTexture()\r\n  /**\r\n   * todo\r\n   * 所有支持WebGL的环境，在片断着色器中至少有8个纹理单元，顶点着色器中可以是0个。\r\n   */\r\n  gl.activeTexture(gl.TEXTURE0) // 可写可不写\r\n  gl.bindTexture(gl.TEXTURE_2D, texture)\r\n  // 设置纹理参数\r\n  // target: gl.TEXTURE_2D\r\n  // TEXTURE_WRAP_S 纹理坐标水平填充       默认值 gl.CLAMP_TO_EDGE\r\n  gl.texParameteri(\r\n    gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE\r\n  )\r\n\r\n  // TEXTURE_WRAP_T纹理坐标垂直填充        默认值 gl.CLAMP_TO_EDGE\r\n  gl.texParameteri(\r\n    gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE\r\n  )\r\n\r\n  // TEXTURE_MIN_FILTER     纹理缩小滤波器     默认值 gl.CLAMP_TO_EDGE\r\n  gl.texParameteri(\r\n    gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST\r\n  )\r\n\r\n  // TEXTURE_MAG_FILTER  纹理放大滤波器       默认值 gl.NEAREST\r\n  gl.texParameteri(\r\n    gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST\r\n  )\r\n  /**\r\n   * todo\r\n   *\r\n   *\r\n   * 指定根据图像二维纹理图像\r\n   * 参数 ：target, level, internalformat, format, type, ImageData? pixels\r\n   *\r\n   */\r\n  gl.texImage2D(\r\n    gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image\r\n  )\r\n\r\n  // =========================================创建图像纹理=============END========================================\r\n\r\n\r\n  // 找到全局变量的位置\r\n  const resolutionLocation = gl.getUniformLocation(program, 'u_resolution')\r\n  const textureSizeLocation = gl.getUniformLocation(program, 'u_textureSize')\r\n  const kernelLocation = gl.getUniformLocation(program, 'u_kernel[0]')\r\n  const kernelWeightLocation = gl.getUniformLocation(program, 'u_kernelWeight')\r\n\r\n  const initialSelection = 'edgeDetect2'\r\n\r\n  // ===============定义一套UI交互=====================================================START===============\r\n  const ui = document.querySelector('#ui')\r\n  const select = document.createElement('select')\r\n  for (const name in kernels) {\r\n    const option = document.createElement('option')\r\n    option.value = name\r\n    if (name === initialSelection) {\r\n      option.selected = true\r\n    }\r\n    option.appendChild(document.createTextNode(name))\r\n    select.appendChild(option)\r\n  }\r\n  select.onchange = function() {\r\n    drawWithKernel(this.options[this.selectedIndex].value)\r\n  }\r\n  ui.appendChild(select)\r\n  drawWithKernel(initialSelection)\r\n\r\n  function computeKernelWeight(kernel) {\r\n    const weight = kernel.reduce(function(prev, curr) {\r\n      return prev + curr\r\n    })\r\n    return weight <= 0 ? 1 : weight\r\n  }\r\n\r\n  // ===============定义一套UI交互=====================================================END===================\r\n\r\n  function drawWithKernel(name) {\r\n\r\n    // 裁剪空间到像素空间\r\n    gl.viewport(\r\n      0, 0, gl.canvas.width, gl.canvas.height\r\n    )\r\n\r\n    // 清除\r\n    gl.clearColor(\r\n      0, 0, 0, 0\r\n    )\r\n    gl.clear(gl.COLOR_BUFFER_BIT)\r\n\r\n    // 使用着色器程序\r\n    gl.useProgram(program)\r\n\r\n    // 开启位置属性\r\n    gl.enableVertexAttribArray(positionLocation)\r\n\r\n    /**\r\n     * todo\r\n     * positionBuffer 缓冲区绑定点\r\n     * positionBuffer存储的是矩形的区域最表点\r\n     */\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)\r\n\r\n    // 设置从positionBuffer中读取数据时的一些参数\r\n    let size = 2          // 每次迭代运行提取两个单位数据\r\n    let type = gl.FLOAT   // 每个单位的数据类型是32位浮点型\r\n    let normalize = false // 不需要归一化数据\r\n    let stride = 0        // 0 = 移动单位数量 * 每个单位占用内存（sizeof(type)）每次迭代运行运动多少内存到下一个数据开始点\r\n    let offset = 0        // 从缓冲起始位置开始读取\r\n    // positionLocation 得到了 positionBuffer的数据\r\n    gl.vertexAttribPointer(\r\n      positionLocation, size, type, normalize, stride, offset\r\n    )\r\n\r\n    // 开启纹理属性\r\n    gl.enableVertexAttribArray(texcoordLocation)\r\n\r\n    /**\r\n     * todo\r\n     * texcoordBuffer 缓冲区绑定点\r\n     * texcoordBuffer 存储的是矩形的纹理映射区域\r\n     */\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer)\r\n    // 设置从texcoordBuffer中读取数据时的一些参数\r\n    size = 2          // 每次迭代运行提取两个单位数据\r\n    type = gl.FLOAT   // 每个单位的数据类型是32位浮点型\r\n    normalize = false // 不需要归一化数据\r\n    stride = 0       // 0 = 移动单位数量 * 每个单位占用内存（sizeof(type)）每次迭代运行运动多少内存到下一个数据开始点\r\n    offset = 0        // 从缓冲起始位置开始读取\r\n\r\n    // texcoordLocation 得到了 texcoordBuffer的数据\r\n    gl.vertexAttribPointer(\r\n      texcoordLocation, size, type, normalize, stride, offset\r\n    )\r\n\r\n    /**\r\n     * todo\r\n     * 设置全局变量 该变量用来处理\r\n     *\r\n     * 像素空间转换到裁剪空间（-1，1）\r\n     * vec2 zeroToOne = a_position / u_resolution;\r\n     */\r\n    gl.uniform2f(\r\n      resolutionLocation, gl.canvas.width, gl.canvas.height\r\n    )\r\n\r\n    // set the size of the image\r\n    /**\r\n     * todo\r\n     * 设置全局变量 该变量用来处理\r\n     *\r\n     * 纹理大小\r\n     * uniform vec2 u_textureSize;\r\n     */\r\n    gl.uniform2f(\r\n      textureSizeLocation, image.width, image.height\r\n    )\r\n\r\n    // 设置全局变量卷积核\r\n    // 设置全局变量卷积核权重\r\n    gl.uniform1fv(kernelLocation, kernels[name])\r\n    gl.uniform1f(kernelWeightLocation, computeKernelWeight(kernels[name]))\r\n\r\n    // 绘制三角形\r\n    const primitiveType = gl.TRIANGLES\r\n    offset = 0\r\n    const  count = 6\r\n    gl.drawArrays(\r\n      primitiveType, offset, count\r\n    )\r\n  }\r\n}\r\n\r\nfunction setRectangle(\r\n  gl, x, y, width, height\r\n) {\r\n  const x1 = x\r\n  const x2 = x + width\r\n  const y1 = y\r\n  const y2 = y + height\r\n  gl.bufferData(\r\n    gl.ARRAY_BUFFER, new Float32Array([\r\n      x1, y2,\r\n      x1, y1,\r\n      x2, y1,\r\n      x1, y2,\r\n      x2, y1,\r\n      x2, y2\r\n    ]), gl.STATIC_DRAW\r\n  )\r\n}\r\n\r\n\r\n\r\n","\r\nimport React, { useRef } from 'react'\r\nimport styles from '../webglCommon/style.less'\r\nimport { triangles } from './triangles'\r\nimport img from './leaves.jpg'\r\n\r\nexport default function WebglImageProcessing() {\r\n  const canvasRef = useRef(null)\r\n  const imgRef = useRef(null)\r\n  const drawTriangles = () => {\r\n    triangles(canvasRef.current, imgRef.current)\r\n  }\r\n  return (\r\n    <div>\r\n      <canvas className={ styles.canvasContainer} ref={canvasRef} width={400} height={300} ></canvas>\r\n      <div>\r\n\r\n        <div id='ui'></div>\r\n        <div className={styles.canvasButton} onClick={drawTriangles}>绘制图形</div>\r\n        <img src={ img } ref={imgRef}/>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","\r\n\r\n// 创建着色器方法，输入参数：渲染上下文，着色器类型，数据源\r\nexport function createShader(\r\n  gl, type, source\r\n) {\r\n  const shader = gl.createShader(type) // 创建着色器对象\r\n  gl.shaderSource(shader, source) // 提供数据源\r\n  gl.compileShader(shader) // 编译 -> 生成着色器\r\n  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS)\r\n  if (success) {\r\n    return shader\r\n  }\r\n\r\n  console.log('getShaderInfoLog', gl.getShaderInfoLog(shader))\r\n  gl.deleteShader(shader)\r\n}\r\n\r\n\r\n// 然后我们将这两个着色器 link（链接）到一个 program（着色程序）\r\nexport function createProgram(\r\n  gl, vertexShader, fragmentShader\r\n) {\r\n  const program = gl.createProgram()\r\n  gl.attachShader(program, vertexShader)\r\n  gl.attachShader(program, fragmentShader)\r\n  gl.linkProgram(program)\r\n\r\n  const success = gl.getProgramParameter(program, gl.LINK_STATUS)\r\n  if (success) {\r\n    return program\r\n  }\r\n\r\n  console.log(gl.getProgramInfoLog(program))\r\n  gl.deleteProgram(program)\r\n}\r\n\r\nexport function createProgramFromStrings(\r\n  gl, vertexShaderSource, fragmentShaderSource\r\n) {\r\n// 创建顶点着色器\r\n  const vertexShader = createShader(\r\n    gl, gl.VERTEX_SHADER, vertexShaderSource\r\n  )\r\n  // 创建片段着色器\r\n  const fragmentShader = createShader(\r\n    gl, gl.FRAGMENT_SHADER, fragmentShaderSource\r\n  )\r\n  // 将两个着色器链接在一起\r\n  return createProgram(\r\n    gl, vertexShader, fragmentShader\r\n  )\r\n}\r\n\r\n\r\n\r\n\r\n// 定义卷积核\r\nexport const kernels = {\r\n  normal: [\r\n    0, 0, 0,\r\n    0, 1, 0,\r\n    0, 0, 0\r\n  ],\r\n  gaussianBlur: [\r\n    0.045, 0.122, 0.045,\r\n    0.122, 0.332, 0.122,\r\n    0.045, 0.122, 0.045\r\n  ],\r\n  gaussianBlur2: [\r\n    1, 2, 1,\r\n    2, 4, 2,\r\n    1, 2, 1\r\n  ],\r\n  gaussianBlur3: [\r\n    0, 1, 0,\r\n    1, 1, 1,\r\n    0, 1, 0\r\n  ],\r\n  unsharpen: [\r\n    -1, -1, -1,\r\n    -1,  9, -1,\r\n    -1, -1, -1\r\n  ],\r\n  sharpness: [\r\n    0, -1, 0,\r\n    -1, 5, -1,\r\n    0, -1, 0\r\n  ],\r\n  sharpen: [\r\n    -1, -1, -1,\r\n    -1, 16, -1,\r\n    -1, -1, -1\r\n  ],\r\n  edgeDetect: [\r\n    -0.125, -0.125, -0.125,\r\n    -0.125,  1,     -0.125,\r\n    -0.125, -0.125, -0.125\r\n  ],\r\n  edgeDetect2: [\r\n    -1, -1, -1,\r\n    -1,  8, -1,\r\n    -1, -1, -1\r\n  ],\r\n  edgeDetect3: [\r\n    -5, 0, 0,\r\n    0, 0, 0,\r\n    0, 0, 5\r\n  ],\r\n  edgeDetect4: [\r\n    -1, -1, -1,\r\n    0,  0,  0,\r\n    1,  1,  1\r\n  ],\r\n  edgeDetect5: [\r\n    -1, -1, -1,\r\n    2,  2,  2,\r\n    -1, -1, -1\r\n  ],\r\n  edgeDetect6: [\r\n    -5, -5, -5,\r\n    -5, 39, -5,\r\n    -5, -5, -5\r\n  ],\r\n  sobelHorizontal: [\r\n    1,  2,  1,\r\n    0,  0,  0,\r\n    -1, -2, -1\r\n  ],\r\n  sobelVertical: [\r\n    1,  0, -1,\r\n    2,  0, -2,\r\n    1,  0, -1\r\n  ],\r\n  previtHorizontal: [\r\n    1,  1,  1,\r\n    0,  0,  0,\r\n    -1, -1, -1\r\n  ],\r\n  previtVertical: [\r\n    1,  0, -1,\r\n    1,  0, -1,\r\n    1,  0, -1\r\n  ],\r\n  boxBlur: [\r\n    0.111, 0.111, 0.111,\r\n    0.111, 0.111, 0.111,\r\n    0.111, 0.111, 0.111\r\n  ],\r\n  triangleBlur: [\r\n    0.0625, 0.125, 0.0625,\r\n    0.125,  0.25,  0.125,\r\n    0.0625, 0.125, 0.0625\r\n  ],\r\n  emboss: [\r\n    -2, -1,  0,\r\n    -1,  1,  1,\r\n    0,  1,  2\r\n  ],\r\n}\r\n\r\n\r\nexport const effects = [\r\n  { name: 'gaussianBlur3', on: true, },\r\n  { name: 'gaussianBlur3', on: true, },\r\n  { name: 'gaussianBlur3', on: true, },\r\n  { name: 'sharpness', },\r\n  { name: 'sharpness', },\r\n  { name: 'sharpness', },\r\n  { name: 'sharpen', },\r\n  { name: 'sharpen', },\r\n  { name: 'sharpen', },\r\n  { name: 'unsharpen', },\r\n  { name: 'unsharpen', },\r\n  { name: 'unsharpen', },\r\n  { name: 'emboss', on: true, },\r\n  { name: 'edgeDetect', },\r\n  { name: 'edgeDetect', },\r\n  { name: 'edgeDetect3', },\r\n  { name: 'edgeDetect3', }\r\n]\r\n","// extracted by mini-css-extract-plugin\nexport default {\"canvasContainer\":\"canvasContainer_AroEJ\",\"canvasUi\":\"canvasUi_B_Bta\",\"canvasButton\":\"canvasButton_l2P0H\"};"],"names":["triangles","canvas","image","gl","getContext","program","createProgramFromStrings","positionLocation","getAttribLocation","texcoordLocation","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","x","y","width","height","x1","x2","y1","y2","bufferData","Float32Array","STATIC_DRAW","setRectangle","texcoordBuffer","texture","createTexture","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","texImage2D","RGBA","UNSIGNED_BYTE","resolutionLocation","getUniformLocation","textureSizeLocation","kernelLocation","kernelWeightLocation","initialSelection","ui","document","querySelector","select","createElement","name","kernels","option","value","selected","appendChild","createTextNode","onchange","drawWithKernel","this","options","selectedIndex","viewport","clearColor","clear","COLOR_BUFFER_BIT","useProgram","enableVertexAttribArray","size","type","FLOAT","normalize","stride","offset","vertexAttribPointer","uniform2f","uniform1fv","uniform1f","kernel","weight","reduce","prev","curr","computeKernelWeight","primitiveType","TRIANGLES","drawArrays","WebglImageProcessing","canvasRef","useRef","imgRef","className","styles","ref","id","onClick","current","src","img","createShader","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","log","getShaderInfoLog","deleteShader","createProgram","vertexShader","fragmentShader","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","vertexShaderSource","fragmentShaderSource","VERTEX_SHADER","FRAGMENT_SHADER","normal","gaussianBlur","gaussianBlur2","gaussianBlur3","unsharpen","sharpness","sharpen","edgeDetect","edgeDetect2","edgeDetect3","edgeDetect4","edgeDetect5","edgeDetect6","sobelHorizontal","sobelVertical","previtHorizontal","previtVertical","boxBlur","triangleBlur","emboss","effects","on"],"sourceRoot":""}